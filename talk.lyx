#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
mcts-nnet talk
\end_layout

\begin_layout Section
Problem Description (3 min)
\end_layout

\begin_layout Subsection
Motion Planning
\end_layout

\begin_layout Itemize
We consider the problem of Motion Planning for Autonomous Driving (AD)
\end_layout

\begin_layout Itemize
where a behavioral planner defines a short-term objective corresponding
 to a desired maneuver.
 The behavioral planner formulates the problem for a local planner, which
 then has to find a feasible trajectory achieving the desired objective
 under a set of constraints.
 
\end_layout

\begin_layout Itemize
To reduce complexity, trajectory planning is typically done in a two-stage
 (path-velocity) process.
 
\end_layout

\begin_deeper
\begin_layout Itemize
First, the local planner computes a set of paths that are kinematically
 feasible and collision-free with respect to static obstacles.
 
\end_layout

\begin_layout Itemize
Secondly, for every candidate path, a velocity profile is generated to avoid
 dynamic obstacles.
 
\end_layout

\end_deeper
\begin_layout Itemize
Trajectory Tracking is done after Motion Planning:
\end_layout

\begin_deeper
\begin_layout Itemize
Using a more detailed dynamics model (instead of a kinematic model) taking
 into account e.g.
 tire models
\end_layout

\end_deeper
\begin_layout Itemize
Tradeoff between Motion Planner and Trajectory Tracking:
\end_layout

\begin_deeper
\begin_layout Itemize
Simpler dynamics/kinematic model for MP as it has to explore much more possibili
ties
\end_layout

\begin_layout Itemize
More complex dynamics model for Trajectory Tracking once a reduced set of
 candidate Motion Plans are identified
\end_layout

\begin_layout Itemize
Tradeoff may vary: if road is wet and curvature high for example.
\end_layout

\end_deeper
\begin_layout Itemize
Motion Planner: -> kinematic models, linearized models
\end_layout

\begin_layout Itemize
Trajectory Tracking: -> dynamics and non-linear models (forces, slip angle
 and ration tire models)
\end_layout

\begin_layout Subsection
Two-Steps Path-Velocity Decomposition
\end_layout

\begin_layout Standard
Speed planning exists in two main motion planning frameworks 
\end_layout

\begin_layout Itemize
Coupled motion planning framework 
\end_layout

\begin_deeper
\begin_layout Itemize
Explore the spatial-temporal space simultaneously using optimization techniques
 or search algorithms 
\end_layout

\end_deeper
\begin_layout Itemize
Decoupled motion planning framework 
\end_layout

\begin_deeper
\begin_layout Itemize
Plan a path first, then regulate the speed along the resulting path 
\end_layout

\begin_layout Itemize
Do speed planning directly along a fixed path (the focus of this paper)
\end_layout

\end_deeper
\begin_layout Standard
Why Speed Profile Planning? 
\end_layout

\begin_layout Itemize
Layered approaches (path planning + speed profile planning) are usually
 more computationally efficient than integrated approaches for trajectory
 planning (case 1).
 
\end_layout

\begin_layout Itemize
In certain cases, a path is spatially fixed.
 The vehicle can only resort to temporal maneuvers to respond to other road
 participants (case 2).
\end_layout

\begin_layout Standard
Summary:
\end_layout

\begin_layout Itemize
We focus on the Motion Planning problem, where we must determine a set of
 acceleration commands along a candidate path, or a set of candidate paths,
 to avoid dynamic obstacles, ensure comfort, and reach a target goal at
 a desired speed.
\end_layout

\begin_layout Itemize
Path planning Conformal Lattice Planner: using eg Clothoids
\end_layout

\begin_layout Itemize
Motion Planner: deriving acceleration commands (in general every 250 ms,
 in emergency situation every 40 ms)
\end_layout

\begin_layout Subsection
Avoiding multiple dynamic obstacles
\end_layout

\begin_layout Itemize
We study the problem of Trajectory Optimization for Autonomous Driving where
 we derive a motion plan on a pre-defined path.
 
\end_layout

\begin_layout Itemize
The challenge is to avoid ten vehicles crossing our path, optimizing efficiency
 and comfort, while making decisions in real-time.
\end_layout

\begin_layout Itemize
The algorithms will be:
\end_layout

\begin_deeper
\begin_layout Itemize
first tested in scenarios with multiple crossing-points.
 
\end_layout

\begin_layout Itemize
We then proceed with Intersection and Automatic Cruise Control (ACC) tests.
\end_layout

\begin_layout Itemize
We finally check the results on single crossing-point tests
\end_layout

\end_deeper
\begin_layout Itemize
For example: we see from Figure that our ego vehicle, represented by the
 blue vector starting at coordinates (200,0) and moving upwards along a
 one-dimensional path, may collide with other dynamic obstacles, shown in
 green (no collision) or red (collision).
 The predicted collision points along the path are depicted in red.
 We note that an interval around the collision point can be defined as "avoidabl
e" regions with a safety margin.
\end_layout

\begin_layout Subsection
Motion Planning Challenges
\end_layout

\begin_layout Standard
We tackle a set of four core challenges in Motion Planning for AD.
 
\end_layout

\begin_layout Itemize
First, the solution must be both accurate and real-time.
 In particular, a motion plan should define control commands every 250 ms,
 but the motion planner may be triggered every 40 ms.
 Most papers focus on accuracy and do not provide details on real-time applicabi
lity of the proposed methods.
 However, this is the main challenge and a core issue for a car manufacturer.
\end_layout

\begin_layout Itemize
The second core challenge is to derive a generic solution that is usable
 for all road geometries and scalable with the number of objects in the
 scene.
\end_layout

\begin_layout Itemize
Third, in order to drive in dense, large, multi-lane, and unsignalized intersect
ions, we must account for multiple crossing-points along the path.
\end_layout

\begin_layout Itemize
Fourth, we want to clearly separate predictions from decisions.
 In some proposals [2]–[5], predictions and decisions are made at the same
 time.
 This makes it challenging for a car manufacturer to root-cause the problem
 when the system does not behave as expected, especially given uncertain
 driving models and sensor measurements.
\end_layout

\begin_layout Section
Problem Formulation (3 min)
\end_layout

\begin_layout Subsection
Complexity Reduction via S-T projection
\end_layout

\begin_layout Itemize
To have a generic problem formulation and to reduce complexity, we project
 the trajectories of the surrounding objects onto the ego path and look
 for a one dimensional motion plan along this path.
 In other words, we define a set of spatio-temporal points 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left
\backslash
{ 
\backslash
left(s_{i},t_{i}
\backslash
right)
\backslash
right
\backslash
} _{i=1..n}$
\end_layout

\end_inset

 we want to avoid, where s is the distance along the path from the ego position,
 t the time, n the number of crossing-points, and ṡ des , the desired speed.
\end_layout

\begin_layout Itemize
Our model differs from a typical state-space representation in that we do
 not model the state vector of all objects in the scene (which would lead
 to a huge state space).
 By defining the intersection points to avoid as a projected space onto
 the ego path, we have a generic problem formulation for the Motion Planner
 that is independent of road geometries and applicable to many objects in
 the scene.
 
\end_layout

\begin_layout Itemize
Furthermore, we have only a single kinematic model (the ego vehicle) embedded
 in a 2D spatio-temporal representation.
 Tree search and model-based algorithms will run much faster than when dealing
 iteratively with the (potentially uncertain) motion models of the surrounding
 objects of a complex POMDP model.
 
\end_layout

\begin_layout Itemize
With this deterministic and generic search model from which sources of uncertain
ties have been pre- analyzed and projected onto the ego path, we combine
 the search with the set of requirements to which we must comply.
\end_layout

\begin_layout Subsection
Uncertainty Handling in S-T graphs
\end_layout

\begin_layout Itemize
We handle uncertainty as per a set-based minimax approach.
 
\end_layout

\begin_layout Itemize
We are dealing with imperfect observations of the surrounding vehicles and
 with even more uncertain driving models.
 As a consequence, the predicted crossing point 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left(t_{
\backslash
text{cross}},s_{
\backslash
text{cross}}
\backslash
right)$
\end_layout

\end_inset

 is uncertain.
 
\end_layout

\begin_layout Itemize
This uncertainty is represented by a random variable 
\begin_inset ERT
status open

\begin_layout Plain Layout

$z$
\end_layout

\end_inset

 and the crossing vehicle can be at any location within an uncertainty area
 represented as a circle in the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left(s,t
\backslash
right)$
\end_layout

\end_inset

 domain; the shadow area in the ST graph (longitudinal position S along
 the path vs Time).
 
\end_layout

\begin_layout Itemize
We try to avoid the whole uncertainty area, complying to the minimax approach
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
underset{x
\backslash
in
\backslash
mathcal{X}}{
\backslash
min}
\backslash
quad
\backslash
underset{z
\backslash
in
\backslash
mathcal{Z}}{
\backslash
max}
\backslash
quad f
\backslash
left(x,z
\backslash
right).$
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
MPC NEW: 
\end_layout

\begin_deeper
\begin_layout Itemize
If we can not avoid the full uncertainty area, we will remain as far as
 possible from its center, via the Elastic Collision Avoidance.
 
\end_layout

\begin_layout Itemize
This Elastic Model strictly enforces dynamics constraints, but relaxes the
 safety distance as little as possible.
\end_layout

\end_deeper
\begin_layout Subsection
Search Model: for A*, MCTS and DQN algorithms
\end_layout

\begin_layout Itemize
We define an MDP model with deterministic transitions and reward models
 based on a set C of crossing-points re-quirements (pre-defined by a prediction
 module) as follows:
\end_layout

\begin_layout Itemize
Surrounding dynamic objects are captured in our model by defining a list
 of spatio-temporal points to avoid.
 Any intersection results in an undesired terminal state, 
\end_layout

\begin_layout Itemize
while the desired terminal state we want to reach is typically defined by
 a Behavioral Planner.
 
\end_layout

\begin_layout Itemize
Cost and reward can be used interchangeably, with the difference only in
 the sign: this model accounts for 
\series bold
efficiency
\series default
 (penalizing every step), 
\series bold
safety
\series default
 (penalizing collisions) and 
\series bold
comfort
\series default
 (penalizing hard braking at −4 ms −2 ).
\end_layout

\begin_layout Subsection
MPC Model: for MPC algorithms
\end_layout

\begin_layout Itemize
We define a MPC problem over 20 time steps of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$250$
\end_layout

\end_inset

 ms each, using a Quadratic Cost function with 
\begin_inset ERT
status open

\begin_layout Plain Layout

$x
\backslash
in
\backslash
mathbb{R}^{2 
\backslash
times 20}, u
\backslash
in
\backslash
mathbb{R}^{20} $
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$160$
\end_layout

\end_inset

 constraints.
 
\end_layout

\begin_layout Itemize
We have 
\begin_inset ERT
status open

\begin_layout Plain Layout

$120$
\end_layout

\end_inset

 linear inequality constraints, which bound the position, velocity, and
 acceleration at every time step
\end_layout

\begin_layout Itemize
up to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$10$
\end_layout

\end_inset

 nonlinear 
\begin_inset ERT
status open

\begin_layout Plain Layout

%($
\backslash
left
\backslash
Vert x_{
\backslash
text{ego}}-x_{
\backslash
text{obj}}
\backslash
right
\backslash
Vert 
\backslash
geq d_{
\backslash
text{saf}}$)
\end_layout

\end_inset

 inequality constraints, where the nonlinear constraints represent the avoidance
 of an interval around a potential collision point; 
\end_layout

\begin_layout Itemize
and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$43$
\end_layout

\end_inset

 linear equality constraints, which represent the linear Dynamics Model
 and the initial condition.
\end_layout

\begin_layout Itemize
We want to avoid up to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$10$
\end_layout

\end_inset

 vehicles crossing our path.
 
\end_layout

\begin_layout Itemize
The spatio-temporal collision points 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left(t_{
\backslash
text{col}}, s_{
\backslash
text{col}}
\backslash
right)$
\end_layout

\end_inset

 are defined with an associated 
\series bold
uncertainty area
\series default
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$t_{
\backslash
text{col}}
\backslash
pm250
\backslash
 ms,
\backslash
 s_{
\backslash
text{col}}
\backslash
pm
\backslash
Delta_{
\backslash
text{safety}}$
\end_layout

\end_inset

 for the position of the ego vehicle with respect to a predicted collision
 point.
\end_layout

\begin_layout Itemize
To handle sharp turns at intersections, we define a set of maximum values
 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(
\backslash
dot{s}_{max}(
\backslash
kappa), 
\backslash
ddot{s}_{max}(
\backslash
kappa))$
\end_layout

\end_inset

 for ego-acceleration and ego-speed depending on the curvature 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
kappa$
\end_layout

\end_inset

, with 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left(s_{f},
\backslash
dot{s}_{f}
\backslash
right)$
\end_layout

\end_inset

 the target for the ego vehicle.
\end_layout

\begin_layout Itemize
In order to ensure comfort, we want to avoid strong accelerations and decelerati
ons.
\end_layout

\begin_layout Section
Algorithms (3 min)
\end_layout

\begin_layout Standard
We define lower and upper bounds for our real-time solution via Baselines
 and Oracles.
\end_layout

\begin_layout Subsection
Baseline
\end_layout

\begin_layout Itemize
With the first baseline (Baseline v1), when a Time To Collision (TTC) is
 below 10 seconds, the agent decelerates at 
\begin_inset Formula $-2\;ms^{-2}$
\end_inset

 to avoid a collision; otherwise the agent accelerates at 
\begin_inset Formula $1\;ms^{-2}$
\end_inset

 , up to a speed limit, to reach the target as fast as possible.
\end_layout

\begin_layout Itemize
The second Baseline (Baseline v2), applies a similar rule but with a very
 strong deceleration, −4 ms −2 , to further limit the collision risk with
 the object with the lowest TTC.
\end_layout

\begin_layout Itemize
These are simple rules which are very intuitive for human drivers.
\end_layout

\begin_layout Subsection
Oracle
\end_layout

\begin_layout Itemize
The Oracle relies on an exhaustive search optimized via Uniform Cost Search
 (UCS or A*) or Dynamic Programming (DP).
 It finds the optimal solution, but it is computationally expensive.
\end_layout

\begin_layout Subsection
MCTS
\end_layout

\begin_layout Itemize
This algorithm involves running many simulations from the current state
 while updating an estimate of the state-action value function Q(s, a) along
 its path of exploration.
\end_layout

\begin_layout Itemize
MCTS balances exploration and exploitation via a method called the Upper
 Confidence Bound
\end_layout

\begin_layout Itemize
After the expansion stage, a rollout phase is run, where many random simulations
 are performed to a fixed depth.
\end_layout

\begin_layout Itemize
For AD we are more constrained in terms of hardware resources and timing
 requirements than for gaming [9], [15], so MCTS can not rely on as many
 rollouts and iterations.
\end_layout

\begin_layout Itemize
Normally, the full set of actions is considered in every state.
 We implement an option to restrict actions, where we remove those actions
 which decrease the smallest TTC, and hence are considered unsafe in a particula
r state.
 If all actions decrease the smallest TTC, we restrict the action set to
 the action with the minimum decrease.
\end_layout

\begin_layout Subsection
DDQN
\end_layout

\begin_layout Itemize
We implement a Double DQN (DDQN) agent [18].
 The objective here is not to learn a model from collected data or from
 an unknown model, but to best fit a faster parametric model (a Neural Network
 in this case) to a slow but very accurate agent.
 Indeed, with UCS and DP search, we have a motion planner that can fulfill
 our accuracy requirements, but this motion planner is very slow.
\end_layout

\begin_layout Itemize
In other words, given a model, with known ego-vehicle dynamics and known
 terminal states, a set of spatio-temporal points we should avoid, and a
 terminal state we want to reach, we perform DDQN training to learn a fast
 parameterized Q-value function, which evaluates a specific action in a
 specific state.
 
\end_layout

\begin_layout Itemize
This function is then used to define a policy when using DDQN in standalone
 mode or used as a heuristic to efficiently guide MCTS tree search, by replacing
 rollouts and initializing Q (s, a) values.
\end_layout

\begin_layout Itemize
In practice, our main issue was to derive a state-space representation enabling
 convergence to a useful function.
 Providing raw information about all constraints with the full set of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
left
\backslash
{ 
\backslash
left(s_{i},t_{i}
\backslash
right)_{i=1..n}
\backslash
right
\backslash
} $
\end_layout

\end_inset

 spatio-temporal points to avoid was unsuccessful, since the network was
 not able to converge.
 
\end_layout

\begin_layout Itemize
We had to use a smaller and more importantly - a sorted list - to enable
 training.
 When the state-space representation is restricted to a list of the three
 most problematic crossing-points, sorted by criticality in terms of smallest
 TTC, the network quickly learns a useful Q-function.
 
\end_layout

\begin_layout Itemize
But then by design, it is clear such a DDQN network will not be able to
 handle the most difficult cases, where reasoning about more than three
 crossing-points is required.
\end_layout

\begin_layout Subsection
MCTS-NNET
\end_layout

\begin_layout Itemize
The learned Q-network Q̂(s, a; w) is used to guide the MCTS tree search,
 similar to [9]–[12], [15].
 In this way, we expand the tree in the most promising areas.
 
\end_layout

\begin_layout Itemize
The main problem of MCTS in our context is the dependency on many online
 statistics and iterations to come up with a good solution.
\end_layout

\begin_layout Itemize
Even if the parametric Q-function is not perfect, as it is using a state
 space representation limited to the three most dangerous objects in the
 scene (for practical reasons explained before), it is expected to provide
 a powerful heuristic.
 
\end_layout

\begin_layout Itemize
The DDQN network, with a representation limited to these three most dangerous
 objects used as heuristic, and the MCTS tree search dealing with the full
 set of requirements (not limited to the three most dangerous objects) are
 clearly complementary.
\end_layout

\begin_layout Itemize
As an additional refinement, we estimate how discriminating the Q-network
 is about a Q (s, a) evaluation, by checking the difference max Q(s,a) with
 min Q(s,a) .
 When this difference is above some threshold, the level of exploration
 is increased.
 To the best of our knowledge, this is a novel feature.
 It is implemented in MCTS-NNET v2
\end_layout

\begin_layout Subsection
MPC
\end_layout

\begin_layout Itemize
Main problem is that the 
\series bold
collision avoidance problem is not convex
\end_layout

\begin_layout Section
Results (3 min)
\end_layout

\begin_layout Standard
We use five metrics to evaluate the performance of our agents.
 
\end_layout

\begin_layout Itemize
The main success metric is the percentage of cases where we reach a target
 state without collision.
 
\end_layout

\begin_layout Itemize
The second metric is the agent runtime.
 The absolute value of this metric is only indicative as the experimental
 software is not optimized and the hardware is a powerful laptop, but it
 nevertheless provides information in terms of real-time applicability and
 how the different algorithms compare to each other.
 Anything above 40 ms is problematic, and ideally we would like to be below
 1 ms.
 
\end_layout

\begin_layout Itemize
The third metric is a comfort metric: the number of hard braking decisions
 (−4 ms −2 ).
 
\end_layout

\begin_layout Itemize
The fourth metric relates to efficiency: how fast we reach a target in numbers
 of steps while complying to some speed limitation.
 
\end_layout

\begin_layout Itemize
The last metric is a safety metric: for eleven of our randomly generated
 test cases, a collision was unavoidable.
 In these cases, we aim for a lower speed at collision.
\end_layout

\begin_layout Subsection
Average Tests Results
\end_layout

\begin_layout Subsection
Distribution of Tests Results
\end_layout

\begin_layout Subsection
Runtime vs Accuracy
\end_layout

\begin_layout Subsection
Very Latest MPC Improvements
\end_layout

\begin_layout Itemize
We benchmark different MPC implementations.
 The parameters are all the same except the collision avoidance model.
 
\end_layout

\begin_deeper
\begin_layout Itemize
We propose a Collision Avoidance model based on an Elastic Model handling
 disjunctive constraints.
 
\end_layout

\begin_layout Itemize
This solution is based on Mixed Integer Programming (22 ms)
\end_layout

\begin_layout Itemize
We also investigate how the Simplex algorithm could be adapted to solve
 aproblem initially defined over a quadratic cost function (6 ms)
\end_layout

\begin_layout Itemize
MPC_MIPe: we replace the boolean variables with real variables such that
 
\begin_inset Formula $\lambda_{i}\in\left[0,1\right],\text{ and an extra\_cost}=-10\sum_{i=1}^{10}\left(\lambda_{i}-0.5\right)²$
\end_inset

 and achieves results similar to MPC_MIP in just 6 ms
\end_layout

\end_deeper
\begin_layout Itemize
In the first implementation (when paper was submitted) we do not use the
 Elastic Model and the binary slack variables to deal with disjunctive constrain
ts.
 
\end_layout

\begin_layout Itemize
Whereas with MPC_MIP-MPC_MIPe-MPC_SIMPLEX we are using our proposed collision
 avoidance model.
 The safety improvement is significant: we not only outperform the reference
 MPC implementation but also reach our upper bound in terms of collision
 avoidancemetric
\end_layout

\begin_layout Itemize
With MPC_SIMPLEX and MPC_MIPe we get a runtime from 
\begin_inset Formula $22\ ms$
\end_inset

 down to 
\begin_inset Formula $6\;ms$
\end_inset


\end_layout

\begin_layout Section
Conclusion (3 min)
\end_layout

\begin_layout Subsection
Motion Planner
\end_layout

\begin_layout Itemize
The proposed system is bench-marked against six other agents, covering a
 wide spectrum of techniques in chal- lenging scenarios where we have to
 deal with multiple crossing-points.
 Our results showed that the proposed agent outperforms other agents for
 many different metrics: safety, comfort, and efficiency, with a runtime
 below 40 ms and a success rate close to 100% over a set of 300 tests.
 
\end_layout

\begin_layout Itemize
There is nevertheless no unique solution that performs best in all cases.
 
\end_layout

\begin_layout Itemize
As a consequence, we propose to combine different agents in a competing
 setting where a 
\series bold
trajectory ranking system
\series default
 determines the best motion plan for the current situation from multiple
 agents.
\end_layout

\begin_layout Subsection
MCTS Improvements
\end_layout

\begin_layout Itemize
Real-time applicability of a MCTS tree search algorithm is enabled with
 a neural network heuristic.
 Deep Learning is used to learn a faster parametric model of a slower but
 known and accurate model.
\end_layout

\begin_layout Itemize
The complexity of the problem is reduced by projecting in the (s, t) domain
 the trajectories of the surrounding objects onto the ego path defining
 a set of spatio-temporal constraints.
\end_layout

\begin_layout Itemize
This projection step accounts for the different sources of uncertainties
 such that the Mo- tion Planning system is left with unambiguous specification
 requirements.
\end_layout

\begin_layout Itemize
In our proposed system, predictions and de- cisions are clearly separated,
 which is usually not the case when applying Deep Reinforcement Learning
 or pure Deep Learning to motion planning.
 Previous work [2]–[5] learn to make predictions and to take decisions at
 the same time.
\end_layout

\begin_layout Subsection
MPC Improvements
\end_layout

\begin_layout Itemize
We propose a Collision Avoidance model based on an Elastic Model handling
 disjunctive constraints.
 
\end_layout

\begin_layout Itemize
This solution is based on Mixed Integer Programming (22 ms)
\end_layout

\begin_layout Itemize
We also investigate how the Simplex algorithm could be adapted to solve
 aproblem initially defined over a quadratic cost function (6 ms)
\end_layout

\begin_layout Itemize
MPC_MIPe: we replace the boolean variables with real variables such that
 
\begin_inset Formula $\lambda_{i}\in\left[0,1\right],\text{ and an extra\_cost}=-10\sum_{i=1}^{10}\left(\lambda_{i}-0.5\right)²$
\end_inset

 and achieves results similar to MPC_MIP in just 6 ms
\end_layout

\begin_layout Itemize
Additional work out there on the topics of speeding up MPC and structural
 exploitation (Hessian matrix is typically a sparse / band matrix) to achieve
 faster speeds
\end_layout

\begin_layout Section
Questions
\end_layout

\begin_layout Standard
This work was started by end of 2019 in the context of a Stanford project
 by Philippe Weingertner and Minnie Ho
\end_layout

\begin_layout Standard
contacts: pweinger@stanford.edu, minnieho@stanford.edu
\end_layout

\end_body
\end_document
